#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Практическая работа №1. Знакомство с потоками.

**Цель:** Познакомиться с возможностями класса System.Thread платформы .NET Framework.

**Результаты:** После выполнения работы Вы сможете:
1. Запускать длительные операции в отдельном потоке.
2. Завершать поток.
3. Дожидаться завершения выполнения потока. 


**Материалы для самостоятельного изучения**.
1. [Основы управления потоками](https://learn.microsoft.com/en-us/dotnet/standard/threading/managed-threading-basics)
2. [Использование потоков](https://learn.microsoft.com/en-us/dotnet/standard/threading/using-threads-and-threading)
3. [Примитив синхронизации Барьер](https://learn.microsoft.com/ru-ru/dotnet/standard/threading/barrier)
4. [Interlocked операции](https://learn.microsoft.com/en-us/dotnet/api/system.threading.interlocked?view=net-8.0)

## Задание.
Реализовать вычисление определенного интеграла методом трапеции в несколько потоков.

Отрезок, на котором происходит вычисление, разбивается на отрезки по количеству потоков. Для каждого отрезка значение 
интеграла считается в отдельном потоке, после завершения вычисоения полученный рельтаты суммирутся.

**Указание**.
1. Для суммирования результатов удобно воспользоваться разделяемой переменной, к которой будут прибалятся результаты вычисления прямо в самом потоке. Для синхронизации операций сложения лучше всего восользоваться [Interlocked операцией](https://learn.microsoft.com/en-us/dotnet/api/system.threading.interlocked?view=net-8.0).
2. Основная функция долна дождаться завершения всех потоков, которые вычисляют значение на отрезках, прежде чем возвратить результат. Для этого удобнее всего использовать Примитив синхронизации Барьер](https://learn.microsoft.com/ru-ru/dotnet/standard/threading/barrier).

#!csharp

using System;
using System.Threading;
using System.Threading.Tasks;
using System.Diagnostics;
//
// Вычисление определенного интеграла
//
class DefiniteIntegral
{
    //
    // a, b - границы отрезка, на котором происходит вычисление опредленного интеграла
    // function - функция, для которой вычисляется определнный интеграл
    // step - размер одного шага разбиения
    // threadsNumber - число потоков, которые используются для вычислений
    //
    public static double[] Solve(double a, double b, Func<double, double> function, double step, int threadsnumber)
    {
        Stopwatch stopwatch = new Stopwatch();
        stopwatch.Start();
        if (a == Double.PositiveInfinity || a == Double.NegativeInfinity ||
            b == Double.PositiveInfinity || b == Double.NegativeInfinity ||
            step == Double.PositiveInfinity || step == Double.NegativeInfinity)
            throw new ArgumentException("Бесконечность на вводе!");
        if (b < a)
            throw new ArgumentException("Некорректные пределы!");
        double result = 0;
        double e = 1E-7;
        double mstep = step / threadsnumber;
        if (mstep < e) throw new ArgumentException("Слишком маленький шаг");
        if (Math.Abs(b - a) < e) throw new ArgumentException("Слишком маленькая разница между пределами интеграла");
        Barrier barrier = new Barrier(threadsnumber);
        int n = Convert.ToInt32(Math.Floor((b - a) / step));
        Parallel.For(0, threadsnumber, i =>
        {
            double lRes = 0;
            for (int j = i; j < n; j += threadsnumber)
            {
                double x1 = a + j * step;
                double x2 = a + (j + 1) * step;
                lRes += (function(x1) + function(x2)) / 2 * step;
            }
            result += lRes;
            barrier.SignalAndWait();
        }
        );
        stopwatch.Stop();
        return [result, stopwatch.ElapsedMilliseconds];
    }
}

#!csharp

#r "nuget: xunit, 2.8.1"
#r "nuget:ScottPlot, 5.0.35"
using Xunit;
using Microsoft.DotNet.Interactive.Formatting;
Formatter.Register(typeof(ScottPlot.Plot), (p, w) => 
    w.Write(((ScottPlot.Plot)p).GetImageHtml(600, 500)), HtmlFormatter.MimeType);
var SIN = (double x) => Math.Sin(x);
double[] dataX = new double[16];
double[] dataY = new double[16];
double bestTime = 1e18;
int bestThread = 0;
for(int thread = 1; thread <= 16; thread++)
{
    double tthrd = 0;
    double timethread = 0;
    for (int test = 1; test <= 10; test++)
    {
        var tstRes = DefiniteIntegral.Solve(-100, 100, SIN, 1e-4, thread);
        Assert.Equal(0, tstRes[0], 1e-4);
        tthrd += tstRes[1];  
    }
    timethread = tthrd / 10;
    dataY[thread - 1] = thread;
    dataX[thread - 1] = timethread;
    if (Math.Min(bestTime, timethread) != bestTime)
    {
        bestTime = Math.Min(bestTime, timethread);
        bestThread = thread;
    }
}
ScottPlot.Plot plt = new();
plt.Add.Scatter(dataX, dataY);
Console.WriteLine($"Лучшее кол-во потоков - {bestThread} за время {bestTime} мс");
plt

#!csharp

//Однопоточное решение задачи
using System.Linq;
using System.Diagnostics;

class TrapezoidalRule {
    public static double Solve(Func<double, double> f, double a, double b, double dx) 
    {
        Stopwatch swch = new Stopwatch();
        swch.Start();
        if (a == Double.PositiveInfinity || a == Double.NegativeInfinity ||
        b == Double.PositiveInfinity || b == Double.NegativeInfinity ||
        dx == Double.PositiveInfinity || dx == Double.NegativeInfinity)
            throw new ArgumentException("Бесконечность на вводе!");
        if (b < a)
            throw new ArgumentException("Некорректные пределы!");
        double result = 0;
        double x = a;
        double e = 1E-7;
        if (dx < e) throw new ArgumentException("Слишком маленький шаг");
        if (Math.Abs(b - a) < e) throw new ArgumentException("Слишком маленькая разница между началом и концом интеграла");
        int n = Convert.ToInt32(Math.Floor((b - a) / dx));
        result = Enumerable.Range(1, n).Select(i => (f(x + i * dx) + f((x + (i - 1) * dx))) / 2 * dx).Sum();
        // if (((b - a) / dx - n) > e)
        // {
        //     result += (f(b) + f((x + n * dx))) / 2 * (b - (x + n * dx));
        // }
        swch.Stop();
        return(swch.ElapsedMilliseconds);
    }
}
var SIN = (double x) => Math.Sin(x);
double tmo = 0;
for (int test = 1; test <= 10; test++)
    {
        tmo += TrapezoidalRule.Solve(SIN, -100, 100, 1e-4);
    }
double timeone = tmo/10;
Console.WriteLine($"Среднее время выполнения - {timeone}");
double perc = timeone / (bestTime / 100) - 100;

#!markdown

# Summary
**Оптимальный размер шага:** 1E-4, так как при 1E-5 и 1E-6 программа выполняется долго, а при 1E-3 и больше вычисления недостаточно точные.

**Оптимальное количество потоков:**   

#!csharp

Console.WriteLine($"{bestThread} потоков за {bestTime} мс");

#!markdown

**Сравнение скорости работы многопоточной программы и однопточной:**

#!csharp

Console.WriteLine($"Многопоточная программа: {bestTime} мс\t Однопоточная программа: {timeone} мс");
Console.WriteLine($"Многопоточная программа выполняется на {Convert.ToInt32(perc)}% быстрее, чем однопоточная. ");
