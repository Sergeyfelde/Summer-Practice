#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Практическая работа №9. Реализация длительных операций.

**Цель:** Предоставить возможность выполннеия команд, для полного завершения которых требуется более одного вызова Execute.

**Результаты:** После выполнения работы Вы сможете:
1. Выполнять длительные опреации в отдельном потоке без монопольного использования потока в течение длительного времени.
3. Прерывать выполнение таких команд. 


## Задание.
Если для полного выполнения командв потребуется более одного вызова Execute, необходимо такую команду добавить в планировщик.

Для иллюстрации выполнненой работы определить команду

#!csharp

using System;
using System.Collections.Concurrent;
using System.Threading;

public interface ICommand
{
    string Name { get; }
    void Execute();
}

public interface IScheduler
{
    bool HasCommand();
    ICommand Select(ServerThread serverThread); 
    void Add(ICommand cmd);
}

public class TestCommand : ICommand
{
    private int id;
    private int counter = 0;
    private int maxCounter;
    private bool isCompleted = false;
    private ServerThread server; 

    public string Name => $"TestCommand {id}";

    public TestCommand(int id, int maxCounter, ServerThread server)
    {
        this.id = id;
        this.maxCounter = maxCounter;
        this.server = server ?? throw new ArgumentNullException(nameof(server));
    }

    public void Execute()
    {
        if (!isCompleted)
        {
            Console.WriteLine($"Поток {id} вызов {++counter}");
            server.IncrementCommandCount();
            if (counter >= maxCounter)
            {
                isCompleted = true;
                Console.WriteLine($"\tПоток {id} завершил выполнение.");
                
            }
        }
    }
}

public class ServerThread
{
    private IScheduler scheduler;
    private Thread thread;
    public bool running = true;
    public ManualResetEvent manualResetEvent = new ManualResetEvent(false);
    private int commandCount = 0;
    private int hardStopTriggerCount;
    private bool hardStopAdded = false;

    public ServerThread(IScheduler scheduler, int hardStopTriggerCount)
    {
        this.scheduler = scheduler ?? throw new ArgumentNullException(nameof(scheduler));
        this.hardStopTriggerCount = hardStopTriggerCount;
        thread = new Thread(Run);
        thread.Start();
    }

    public void EnqueueCommand(ICommand command)
    {
        if (command == null) throw new ArgumentNullException(nameof(command));
        scheduler.Add(command);
        manualResetEvent.Set();
    }

    public void IncrementCommandCount()
    {
        commandCount++;
        //Console.WriteLine($"commandCount увеличен: {commandCount}");
        if (commandCount >= hardStopTriggerCount && !hardStopAdded)
        {
            //Console.WriteLine("Добавление HardStop в очередь");
            scheduler.Add(new HardStop(this));
            hardStopAdded = true;
        }
    }

    private void Run()
    {
        while (running)
        {
            manualResetEvent.WaitOne();
            manualResetEvent.Reset();

            while (running && scheduler.HasCommand())
            {
                ICommand command = scheduler.Select(this);
                try
                {
                    command.Execute();
                }
                catch (Exception ex)
                {
                    ExceptionHandler(command, ex);
                }
            }
        }
    }

    public void Stop()
    {
        running = false;
        manualResetEvent.Set();
        thread.Join();
    }

    private void ExceptionHandler(ICommand command, Exception ex)
    {
        Console.WriteLine($"Исключение в команде {command.Name}: {ex.Message}");
    }
}

public class HardStop : ICommand
{
    private ServerThread serverThread;
    public string Name => "HardStop";

    public HardStop(ServerThread serverThread)
    {
        this.serverThread = serverThread ?? throw new ArgumentNullException(nameof(serverThread));
    }

    public void Execute()
    {
        //Console.WriteLine("Выполнение команды: HardStop");
        serverThread.Stop();
    }
}

public class RoundRobinScheduler : IScheduler
{
    private ConcurrentQueue<ICommand> queueCmd = new ConcurrentQueue<ICommand>();
    private bool immediateHardStop = false;

    public bool HasCommand()
    {
        return !queueCmd.IsEmpty || immediateHardStop;
    }

    public ICommand Select(ServerThread serverThread)
    {
        if (immediateHardStop)
        {
            immediateHardStop = false;
            return new HardStop(serverThread);
        }

        if (queueCmd.TryDequeue(out ICommand command))
        {
            return command;
        }
        return null;
    }

    public void Add(ICommand cmd)
    {
        if (cmd is HardStop)
        {
            immediateHardStop = true;
        }
        else
        {
            queueCmd.Enqueue(cmd);
        }
        //Console.WriteLine($"Добавление команды: {cmd.GetType().Name}");
    }
}


public class ScheduledCommand : ICommand
{
    private ICommand command;
    private IScheduler scheduler;
    private int countEx;
    private int maxEx;
    public string Name => command.Name;

    public ScheduledCommand(ICommand command, IScheduler scheduler, int maxEx)
    {
        this.command = command ?? throw new ArgumentNullException(nameof(command));
        this.scheduler = scheduler ?? throw new ArgumentNullException(nameof(scheduler));
        this.maxEx = maxEx;
        countEx = 0;
    }

    public void Execute()
    {
        command.Execute();
        countEx++;
        //Console.WriteLine($"Выполнение команды: {this.GetType().Name}");
        if (countEx < maxEx)
        {
            scheduler.Add(this);
        }
    }
}

int hardStopTriggerCount = 15; // Вызов HardStop после 15 выполненных команд
IScheduler scheduler = new RoundRobinScheduler();
ServerThread serverThread = new ServerThread(scheduler, hardStopTriggerCount);
for (int i = 1; i <= 5; i++)
{
    ICommand testCmd = new TestCommand(i, 3, serverThread);
    ICommand scheduledCmd = new ScheduledCommand(testCmd, scheduler, 3);
    serverThread.EnqueueCommand(scheduledCmd);
}

#!markdown

Необходимо проиллюстрировать выполнение 5 экземпляров TestCommand 3 раза, затем остановить поток с помощью HardStop.
